# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: massa/model/v1/block.proto, massa/model/v1/commons.proto, massa/model/v1/draw.proto, massa/model/v1/endorsement.proto, massa/model/v1/execution.proto, massa/model/v1/operation.proto, massa/model/v1/slot.proto, massa/model/v1/versioning.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import (
    List,
    Optional,
)

import betterproto


class OperationStatus(betterproto.Enum):
    """Possible statuses for an operation"""

    OPERATION_STATUS_UNSPECIFIED = 0
    OPERATION_STATUS_PENDING = 1
    OPERATION_STATUS_FINAL = 2
    OPERATION_STATUS_SUCCESS = 3
    OPERATION_STATUS_FAILURE = 4
    OPERATION_STATUS_UNKNOWN = 5


class BlockStatus(betterproto.Enum):
    """Possible statuses for a block"""

    BLOCK_STATUS_UNSPECIFIED = 0
    BLOCK_STATUS_IN_BLOCKCLIQUE = 1
    BLOCK_STATUS_FINAL = 2
    BLOCK_STATUS_CANDIDATE = 3
    BLOCK_STATUS_DISCARDED = 4


class ScExecutionEventStatus(betterproto.Enum):
    """ScExecutionEventStatus type enum"""

    SC_EXECUTION_EVENT_STATUS_UNSPECIFIED = 0
    SC_EXECUTION_EVENT_STATUS_FINAL = 1
    SC_EXECUTION_EVENT_STATUS_READ_ONLY = 2
    SC_EXECUTION_EVENT_STATUS_FAILURE = 3


class ExecutionOutputStatus(betterproto.Enum):
    """ExecutionOutputStatus type enum"""

    EXECUTION_OUTPUT_STATUS_UNSPECIFIED = 0
    EXECUTION_OUTPUT_STATUS_CANDIDATE = 1
    EXECUTION_OUTPUT_STATUS_FINAL = 2


class OperationExecutionStatus(betterproto.Enum):
    """OperationExecutionStatus type enum"""

    OPERATION_EXECUTION_STATUS_UNSPECIFIED = 0
    OPERATION_EXECUTION_STATUS_SUCCESS = 1
    OPERATION_EXECUTION_STATUS_FAILED = 2


class AsyncPoolChangeType(betterproto.Enum):
    """AsyncPoolChangeType type enum"""

    ASYNC_POOL_CHANGE_TYPE_UNSPECIFIED = 0
    ASYNC_POOL_CHANGE_TYPE_SET = 1
    ASYNC_POOL_CHANGE_TYPE_UPDATE = 2
    ASYNC_POOL_CHANGE_TYPE_DELETE = 3


class LedgerChangeType(betterproto.Enum):
    """LedgerChangeType type enum"""

    LEDGER_CHANGE_TYPE_UNSPECIFIED = 0
    LEDGER_CHANGE_TYPE_SET = 1
    LEDGER_CHANGE_TYPE_UPDATE = 2
    LEDGER_CHANGE_TYPE_DELETE = 3


class SetOrKeepType(betterproto.Enum):
    """SetOrKeepType type enum"""

    SET_OR_KEEP_TYPE_UNSPECIFIED = 0
    SET_OR_KEEP_TYPE_SET = 1
    SET_OR_KEEP_TYPE_KEEP = 2


class SetOrDeleteType(betterproto.Enum):
    """SetOrDeleteType type enum"""

    SET_OR_DELETE_TYPE_UNSPECIFIED = 0
    SET_OR_DELETE_TYPE_SET = 1
    SET_OR_DELETE_TYPE_DELETE = 2


class ComponentStateId(betterproto.Enum):
    """
    State machine for a Versioning component that tracks the deployment state
    """

    COMPONENT_STATE_ID_UNSPECIFIED = 0
    COMPONENT_STATE_ID_ERROR = 1
    COMPONENT_STATE_ID_DEFINED = 2
    COMPONENT_STATE_ID_STARTED = 3
    COMPONENT_STATE_ID_LOCKEDIN = 4
    COMPONENT_STATE_ID_ACTIVE = 5
    COMPONENT_STATE_ID_FAILED = 6


class MipComponent(betterproto.Enum):
    """Versioning component enum"""

    MIP_COMPONENT_UNSPECIFIED = 0
    MIP_COMPONENT_ADDRESS = 1
    MIP_COMPONENT_KEYPAIR = 2


@dataclass(eq=False, repr=False)
class IndexedSlot(betterproto.Message):
    """
    When an address is drawn to create an endorsement it is selected for a
    specific index
    """

    slot: "Slot" = betterproto.message_field(1)
    """Slot"""

    index: int = betterproto.fixed64_field(2)
    """Endorsement index in the slot"""


@dataclass(eq=False, repr=False)
class Slot(betterproto.Message):
    """A point in time where a block is expected"""

    period: int = betterproto.fixed64_field(1)
    """Period"""

    thread: int = betterproto.fixed32_field(2)
    """Thread"""


@dataclass(eq=False, repr=False)
class Endorsement(betterproto.Message):
    """An endorsement, as sent in the network"""

    slot: "Slot" = betterproto.message_field(1)
    """Slot in which the endorsement can be included"""

    index: int = betterproto.fixed32_field(2)
    """Endorsement index inside the including block"""

    endorsed_block: str = betterproto.string_field(3)
    """
    Hash of endorsed block This is the parent in thread `self.slot.thread` of
    the block in which the endorsement is included
    """


@dataclass(eq=False, repr=False)
class SignedEndorsement(betterproto.Message):
    """Signed endorsement"""

    content: "Endorsement" = betterproto.message_field(1)
    """Endorsement"""

    signature: str = betterproto.string_field(2)
    """
    A cryptographically generated value using `serialized_data` and a public
    key.
    """

    content_creator_pub_key: str = betterproto.string_field(3)
    """The public-key component used in the generation of the signature"""

    content_creator_address: str = betterproto.string_field(4)
    """Derived from the same public key used to generate the signature"""

    id: str = betterproto.string_field(5)
    """A secure hash of the data. See also [massa_hash::Hash]"""


@dataclass(eq=False, repr=False)
class BytesMapFieldEntry(betterproto.Message):
    """BytesMapFieldEntry"""

    key: bytes = betterproto.bytes_field(1)
    """bytes key"""

    value: bytes = betterproto.bytes_field(2)
    """bytes key"""


@dataclass(eq=False, repr=False)
class SecureShare(betterproto.Message):
    """
    Packages a type such that it can be securely sent and received in a trust-
    free network
    """

    serialized_data: bytes = betterproto.bytes_field(1)
    """
    Content in sharable, deserializable form. Is used in the secure
    verification protocols
    """

    signature: str = betterproto.string_field(2)
    """
    A cryptographically generated value using `serialized_data` and a public
    key.
    """

    content_creator_pub_key: str = betterproto.string_field(3)
    """The public-key component used in the generation of the signature"""

    content_creator_address: str = betterproto.string_field(4)
    """Derived from the same public key used to generate the signature"""

    id: str = betterproto.string_field(5)
    """A secure hash of the data. See also [massa_hash::Hash]"""


@dataclass(eq=False, repr=False)
class Operation(betterproto.Message):
    """The operation as sent in the network"""

    fee: int = betterproto.fixed64_field(1)
    """The fee they have decided for this operation"""

    expire_period: int = betterproto.fixed64_field(2)
    """
    After `expire_period` slot the operation won't be included in a block
    """

    op: "OperationType" = betterproto.message_field(3)
    """The type specific operation part"""


@dataclass(eq=False, repr=False)
class OperationType(betterproto.Message):
    """Type specific operation content"""

    transaction: "Transaction" = betterproto.message_field(1, group="type")
    """Transfer coins from sender to recipient"""

    roll_buy: "RollBuy" = betterproto.message_field(2, group="type")
    """
    The sender buys `roll_count` rolls. Roll price is defined in configuration
    """

    roll_sell: "RollSell" = betterproto.message_field(3, group="type")
    """
    The sender sells `roll_count` rolls. Roll price is defined in configuration
    """

    execut_sc: "ExecuteSc" = betterproto.message_field(4, group="type")
    """Execute a smart contract"""

    call_sc: "CallSc" = betterproto.message_field(5, group="type")
    """Calls an exported function from a stored smart contract"""


@dataclass(eq=False, repr=False)
class Transaction(betterproto.Message):
    """Transfer coins from sender to recipient"""

    recipient_address: str = betterproto.string_field(1)
    """Recipient address"""

    amount: int = betterproto.fixed64_field(2)
    """Amount"""


@dataclass(eq=False, repr=False)
class RollBuy(betterproto.Message):
    """
    The sender buys `roll_count` rolls. Roll price is defined in configuration
    """

    roll_count: int = betterproto.fixed64_field(1)
    """Roll count"""


@dataclass(eq=False, repr=False)
class RollSell(betterproto.Message):
    """
    The sender sells `roll_count` rolls. Roll price is defined in configuration
    """

    roll_count: int = betterproto.fixed64_field(1)
    """Roll count"""


@dataclass(eq=False, repr=False)
class ExecuteSc(betterproto.Message):
    """Execute a smart contract"""

    data: bytes = betterproto.bytes_field(1)
    """Smart contract bytecode."""

    max_coins: int = betterproto.fixed64_field(2)
    """The maximum of coins that could be spent by the operation sender"""

    max_gas: int = betterproto.fixed64_field(3)
    """
    The maximum amount of gas that the execution of the contract is allowed to
    cost
    """

    datastore: List["BytesMapFieldEntry"] = betterproto.message_field(4)
    """A key-value store associating a hash to arbitrary bytes"""


@dataclass(eq=False, repr=False)
class CallSc(betterproto.Message):
    """Calls an exported function from a stored smart contract"""

    target_addr: str = betterproto.string_field(1)
    """Target smart contract address"""

    target_func: str = betterproto.string_field(2)
    """Target function name. No function is called if empty"""

    param: bytes = betterproto.bytes_field(3)
    """Parameter to pass to the target function"""

    max_gas: int = betterproto.fixed64_field(4)
    """
    The maximum amount of gas that the execution of the contract is allowed to
    cost
    """

    coins: int = betterproto.fixed64_field(5)
    """
    Extra coins that are spent from the caller's balance and transferred to the
    target
    """


@dataclass(eq=False, repr=False)
class SignedOperation(betterproto.Message):
    """Signed operation"""

    content: "Operation" = betterproto.message_field(1)
    """Operation"""

    signature: str = betterproto.string_field(2)
    """
    A cryptographically generated value using `serialized_data` and a public
    key.
    """

    content_creator_pub_key: str = betterproto.string_field(3)
    """The public-key component used in the generation of the signature"""

    content_creator_address: str = betterproto.string_field(4)
    """Derived from the same public key used to generate the signature"""

    id: str = betterproto.string_field(5)
    """A secure hash of the data. See also [massa_hash::Hash]"""


@dataclass(eq=False, repr=False)
class OperationWrapper(betterproto.Message):
    """A wrapper around an operation with its metadata"""

    id: str = betterproto.string_field(1)
    """The unique ID of the operation."""

    block_ids: List[str] = betterproto.string_field(3)
    """The IDs of the blocks in which the operation appears"""

    thread: int = betterproto.fixed32_field(5)
    """The thread in which the operation can be included"""

    operation: "SignedOperation" = betterproto.message_field(6)
    """The operation object itself"""

    status: List["OperationStatus"] = betterproto.enum_field(7)
    """The execution statuses of the operation"""


@dataclass(eq=False, repr=False)
class Block(betterproto.Message):
    """Block"""

    header: "SignedBlockHeader" = betterproto.message_field(1)
    """Signed header"""

    operations: List[str] = betterproto.string_field(2)
    """Operations ids"""


@dataclass(eq=False, repr=False)
class FilledBlock(betterproto.Message):
    """Filled block"""

    header: "SignedBlockHeader" = betterproto.message_field(1)
    """Signed header"""

    operations: List["FilledOperationTuple"] = betterproto.message_field(2)
    """Operations"""


@dataclass(eq=False, repr=False)
class BlockHeader(betterproto.Message):
    """Block header"""

    slot: "Slot" = betterproto.message_field(1)
    """Slot"""

    parents: List[str] = betterproto.string_field(2)
    """parents"""

    operation_merkle_root: str = betterproto.string_field(3)
    """All operations hash"""

    endorsements: List["SignedEndorsement"] = betterproto.message_field(4)
    """Signed endorsements"""


@dataclass(eq=False, repr=False)
class FilledOperationTuple(betterproto.Message):
    """Filled Operation Tuple"""

    operation_id: str = betterproto.string_field(1)
    """Operation id"""

    operation: "SignedOperation" = betterproto.message_field(2)
    """Signed operation"""


@dataclass(eq=False, repr=False)
class SignedBlock(betterproto.Message):
    """Signed block"""

    content: "Block" = betterproto.message_field(1)
    """Block"""

    signature: str = betterproto.string_field(2)
    """
    A cryptographically generated value using `serialized_data` and a public
    key.
    """

    content_creator_pub_key: str = betterproto.string_field(3)
    """The public-key component used in the generation of the signature"""

    content_creator_address: str = betterproto.string_field(4)
    """Derived from the same public key used to generate the signature"""

    id: str = betterproto.string_field(5)
    """A secure hash of the data. See also [massa_hash::Hash]"""


@dataclass(eq=False, repr=False)
class SignedBlockHeader(betterproto.Message):
    """Signed block header"""

    content: "BlockHeader" = betterproto.message_field(1)
    """BlockHeader"""

    signature: str = betterproto.string_field(2)
    """
    A cryptographically generated value using `serialized_data` and a public
    key.
    """

    content_creator_pub_key: str = betterproto.string_field(3)
    """The public-key component used in the generation of the signature"""

    content_creator_address: str = betterproto.string_field(4)
    """Derived from the same public key used to generate the signature"""

    id: str = betterproto.string_field(5)
    """A secure hash of the data. See also [massa_hash::Hash]"""


@dataclass(eq=False, repr=False)
class BlockWrapper(betterproto.Message):
    """A wrapper around a block with its metadata"""

    id: str = betterproto.string_field(1)
    """The unique ID of the block."""

    block: "Block" = betterproto.message_field(2)
    """The block object itself"""

    status: List["BlockStatus"] = betterproto.enum_field(3)
    """The execution statuses of the block"""


@dataclass(eq=False, repr=False)
class SelectorDraws(betterproto.Message):
    """Selector draws"""

    address: str = betterproto.string_field(1)
    """Address"""

    next_block_draws: List["Slot"] = betterproto.message_field(2)
    """Next block draws"""

    next_endorsement_draws: List["IndexedSlot"] = betterproto.message_field(3)
    """Next endorsements draws"""


@dataclass(eq=False, repr=False)
class SlotExecutionOutput(betterproto.Message):
    """SlotExecutionOutput"""

    status: List["ExecutionOutputStatus"] = betterproto.enum_field(1)
    """Status"""

    execution_output: "ExecutionOutput" = betterproto.message_field(2)
    """Executed slot output"""


@dataclass(eq=False, repr=False)
class FinalizedExecutionOutput(betterproto.Message):
    """FinalizedExecutionOutput"""

    slot: "Slot" = betterproto.message_field(1)
    """Slot"""


@dataclass(eq=False, repr=False)
class ExecutionOutput(betterproto.Message):
    """ExecutionOutput"""

    slot: "Slot" = betterproto.message_field(1)
    """Slot"""

    block_id: Optional[str] = betterproto.string_field(
        2, optional=True, group="_block_id"
    )
    """Block id at that slot (optional)"""

    events: List["ScExecutionEvent"] = betterproto.message_field(3)
    """Events emitted by the execution step"""

    state_changes: "StateChanges" = betterproto.message_field(4)
    """State changes caused by the execution step"""


@dataclass(eq=False, repr=False)
class ScExecutionEvent(betterproto.Message):
    """ScExecutionEvent"""

    context: "ScExecutionEventContext" = betterproto.message_field(1)
    """Sc execution context"""

    data: str = betterproto.string_field(2)
    """json data string"""


@dataclass(eq=False, repr=False)
class ScExecutionEventContext(betterproto.Message):
    """ScExecutionEvent context"""

    id: str = betterproto.string_field(1)
    """base58 encoded slot(period + thread) + index_in_slot"""

    origin_slot: "Slot" = betterproto.message_field(2)
    """When was it generated"""

    block_id: Optional[str] = betterproto.string_field(
        3, optional=True, group="_block_id"
    )
    """Block id if there was a block at that slot (optional)"""

    index_in_slot: int = betterproto.fixed64_field(4)
    """Index of the event in the slot"""

    call_stack: List[str] = betterproto.string_field(5)
    """Call stack addresses. most recent at the end"""

    origin_operation_id: Optional[str] = betterproto.string_field(
        6, optional=True, group="_origin_operation_id"
    )
    """Origin operation id (optional)"""

    status: List["ScExecutionEventStatus"] = betterproto.enum_field(7)
    """Status"""


@dataclass(eq=False, repr=False)
class StateChanges(betterproto.Message):
    """StateChanges"""

    ledger_changes: List["LedgerChangeEntry"] = betterproto.message_field(1)
    """Ledger changes"""

    async_pool_changes: List["AsyncPoolChangeEntry"] = betterproto.message_field(2)
    """Asynchronous pool changes"""

    executed_ops_changes: List["ExecutedOpsChangeEntry"] = betterproto.message_field(4)
    """Executed operations changes"""

    executed_denunciations_changes: List[
        "DenunciationIndex"
    ] = betterproto.message_field(5)
    """Executed denunciations changes"""


@dataclass(eq=False, repr=False)
class ExecutedOpsChangeEntry(betterproto.Message):
    """ExecutedOpsChangeEntry"""

    operation_id: str = betterproto.string_field(1)
    """OperationId"""

    value: "ExecutedOpsChangeValue" = betterproto.message_field(2)
    """ExecutedOpsChangeValue"""


@dataclass(eq=False, repr=False)
class ExecutedOpsChangeValue(betterproto.Message):
    """ExecutedOpsChangeValue"""

    status: List["OperationExecutionStatus"] = betterproto.enum_field(1)
    """The status of the execution of the operation"""

    slot: "Slot" = betterproto.message_field(2)
    """Slot until which the operation remains valid (included)"""


@dataclass(eq=False, repr=False)
class AsyncPoolChangeEntry(betterproto.Message):
    """AsyncPoolChange Entry"""

    async_message_id: str = betterproto.string_field(1)
    """Async message id"""

    value: "AsyncPoolChangeValue" = betterproto.message_field(2)
    """AsyncPool message"""


@dataclass(eq=False, repr=False)
class AsyncPoolChangeValue(betterproto.Message):
    """AsyncPoolChangeValue"""

    type: "AsyncPoolChangeType" = betterproto.enum_field(1)
    """The type of the change"""

    created_message: "AsyncMessage" = betterproto.message_field(2, group="message")
    """Created ledger entry"""

    updated_message: "AsyncMessageUpdate" = betterproto.message_field(
        3, group="message"
    )
    """Update ledger entry"""


@dataclass(eq=False, repr=False)
class AsyncMessage(betterproto.Message):
    """Asynchronous smart contract message"""

    emission_slot: "Slot" = betterproto.message_field(1)
    """Slot at which the message was emitted"""

    emission_index: int = betterproto.fixed64_field(2)
    """
    Index of the emitted message within the `emission_slot`. This is used for
    disambiguate the emission of multiple messages at the same slot.
    """

    sender: str = betterproto.string_field(3)
    """The address that sent the message"""

    destination: str = betterproto.string_field(4)
    """The address towards which the message is being sent"""

    handler: str = betterproto.string_field(5)
    """the handler function name within the destination address' bytecode"""

    max_gas: int = betterproto.fixed64_field(6)
    """Maximum gas to use when processing the message"""

    fee: int = betterproto.fixed64_field(7)
    """Fee paid by the sender when the message is processed."""

    coins: int = betterproto.fixed64_field(8)
    """
    Coins sent from the sender to the target address of the message. Those
    coins are spent by the sender address when the message is sent, and
    credited to the destination address when receiving the message. In case of
    failure or discard, those coins are reimbursed to the sender.
    """

    validity_start: "Slot" = betterproto.message_field(9)
    """
    Slot at which the message starts being valid (bound included in the
    validity range)
    """

    validity_end: "Slot" = betterproto.message_field(10)
    """
    Slot at which the message stops being valid (bound not included in the
    validity range)
    """

    data: bytes = betterproto.bytes_field(11)
    """Raw payload data of the message"""

    trigger: "AsyncMessageTrigger" = betterproto.message_field(12)
    """Trigger that define whenever a message can be executed"""

    can_be_executed: bool = betterproto.bool_field(13)
    """
    Boolean that determine if the message can be executed. For messages without
    filter this boolean is always true. For messages with filter, this boolean
    is true if the filter has been matched between `validity_start` and current
    slot.
    """

    hash: str = betterproto.string_field(14)
    """Hash of the message"""


@dataclass(eq=False, repr=False)
class AsyncMessageUpdate(betterproto.Message):
    """Asynchronous smart contract message"""

    emission_slot: "SetOrKeepSlot" = betterproto.message_field(1)
    """Change the slot at which the message was emitted"""

    emission_index: "SetOrKeepFixed64" = betterproto.message_field(2)
    """
    Change the index of the emitted message within the `emission_slot`. This is
    used for disambiguate the emission of multiple messages at the same slot.
    """

    sender: "SetOrKeepString" = betterproto.message_field(3)
    """Change the address that sent the message"""

    destination: "SetOrKeepString" = betterproto.message_field(4)
    """Change the address towards which the message is being sent"""

    handler: "SetOrKeepString" = betterproto.message_field(5)
    """
    Change the handler function name within the destination address' bytecode
    """

    max_gas: "SetOrKeepFixed64" = betterproto.message_field(6)
    """Change the maximum gas to use when processing the message"""

    fee: "SetOrKeepFixed64" = betterproto.message_field(7)
    """Change the fee paid by the sender when the message is processed."""

    coins: "SetOrKeepFixed64" = betterproto.message_field(8)
    """
    Change the coins sent from the sender to the target address of the message.
    Those coins are spent by the sender address when the message is sent, and
    credited to the destination address when receiving the message. In case of
    failure or discard, those coins are reimbursed to the sender.
    """

    validity_start: "SetOrKeepSlot" = betterproto.message_field(9)
    """
    Change the slot at which the message starts being valid (bound included in
    the validity range)
    """

    validity_end: "SetOrKeepSlot" = betterproto.message_field(10)
    """
    Change the slot at which the message stops being valid (bound not included
    in the validity range)
    """

    data: "SetOrKeepBytes" = betterproto.message_field(11)
    """Change the raw payload data of the message"""

    trigger: "SetOrKeepAsyncMessageTrigger" = betterproto.message_field(12)
    """Change the trigger that define whenever a message can be executed"""

    can_be_executed: "SetOrKeepBool" = betterproto.message_field(13)
    """
    Change the boolean that determine if the message can be executed. For
    messages without filter this boolean is always true. For messages with
    filter, this boolean is true if the filter has been matched between
    `validity_start` and current slot.
    """

    hash: "SetOrKeepString" = betterproto.message_field(14)
    """Change the hash of the message"""


@dataclass(eq=False, repr=False)
class SetOrKeepSlot(betterproto.Message):
    """Set or Keep Slot"""

    type: "SetOrKeepType" = betterproto.enum_field(1)
    """The type of the change"""

    value: Optional["Slot"] = betterproto.message_field(
        2, optional=True, group="_value"
    )
    """The value of that entry (optional)"""


@dataclass(eq=False, repr=False)
class SetOrKeepFixed64(betterproto.Message):
    """Set or Keep Fixed64"""

    type: "SetOrKeepType" = betterproto.enum_field(1)
    """The type of the change"""

    value: Optional[int] = betterproto.fixed64_field(2, optional=True, group="_value")
    """The value of that entry (optional)"""


@dataclass(eq=False, repr=False)
class SetOrKeepString(betterproto.Message):
    """Set or Keep String"""

    type: "SetOrKeepType" = betterproto.enum_field(1)
    """The type of the change"""

    value: Optional[str] = betterproto.string_field(2, optional=True, group="_value")
    """The value of that entry (optional)"""


@dataclass(eq=False, repr=False)
class SetOrKeepBytes(betterproto.Message):
    """Set or Keep Bytes"""

    type: "SetOrKeepType" = betterproto.enum_field(1)
    """The type of the change"""

    value: Optional[bytes] = betterproto.bytes_field(2, optional=True, group="_value")
    """The value of that entry (optional)"""


@dataclass(eq=False, repr=False)
class SetOrKeepBool(betterproto.Message):
    """Set or Keep Bool"""

    type: "SetOrKeepType" = betterproto.enum_field(1)
    """The type of the change"""

    value: Optional[bool] = betterproto.bool_field(2, optional=True, group="_value")
    """The value of that entry (optional)"""


@dataclass(eq=False, repr=False)
class SetOrKeepAsyncMessageTrigger(betterproto.Message):
    """Set or Keep AsyncMessageTrigger"""

    type: "SetOrKeepType" = betterproto.enum_field(1)
    """The type of the change"""

    value: Optional["AsyncMessageTrigger"] = betterproto.message_field(
        2, optional=True, group="_value"
    )
    """The value of that entry (optional)"""


@dataclass(eq=False, repr=False)
class AsyncMessageTrigger(betterproto.Message):
    """Structure defining a trigger for an asynchronous message"""

    address: str = betterproto.string_field(1)
    """Filter on the address"""

    datastore_key: Optional[bytes] = betterproto.bytes_field(
        2, optional=True, group="_datastore_key"
    )
    """Filter on the datastore key (optional)"""


@dataclass(eq=False, repr=False)
class LedgerChangeEntry(betterproto.Message):
    """LedgerChangeEntry"""

    address: str = betterproto.string_field(1)
    """Address"""

    value: "LedgerChangeValue" = betterproto.message_field(2)
    """Ledger message"""


@dataclass(eq=False, repr=False)
class LedgerChangeValue(betterproto.Message):
    """LedgerChangeValue"""

    type: "LedgerChangeType" = betterproto.enum_field(1)
    """The type of the change"""

    created_entry: "LedgerEntry" = betterproto.message_field(2, group="entry")
    """Created ledger entry"""

    updated_entry: "LedgerEntryUpdate" = betterproto.message_field(3, group="entry")
    """Update ledger entry"""


@dataclass(eq=False, repr=False)
class LedgerEntry(betterproto.Message):
    """An entry associated to an address in the `FinalLedger`"""

    balance: int = betterproto.fixed64_field(1)
    """The balance of that entry"""

    bytecode: bytes = betterproto.bytes_field(2)
    """Executable bytecode"""

    entries: List["BytesMapFieldEntry"] = betterproto.message_field(3)
    """A key-value store associating a hash to arbitrary bytes"""


@dataclass(eq=False, repr=False)
class LedgerEntryUpdate(betterproto.Message):
    """Represents an update to one or more fields of a `LedgerEntry`"""

    balance: "SetOrKeepBalance" = betterproto.message_field(1)
    """Change the balance"""

    bytecode: "SetOrKeepBytecode" = betterproto.message_field(2)
    """Change the executable bytecode"""

    datastore: List["SetOrDeleteDatastoreEntry"] = betterproto.message_field(3)
    """/ Change datastore entries"""


@dataclass(eq=False, repr=False)
class SetOrKeepBalance(betterproto.Message):
    """Set or Keep Balance"""

    type: "SetOrKeepType" = betterproto.enum_field(1)
    """The type of the change"""

    balance: Optional[int] = betterproto.fixed64_field(
        2, optional=True, group="_balance"
    )
    """The balance of that entry (optional)"""


@dataclass(eq=False, repr=False)
class SetOrKeepBytecode(betterproto.Message):
    """Set or Keep Bytecode"""

    type: "SetOrKeepType" = betterproto.enum_field(1)
    """The type of the change"""

    bytecode: Optional[bytes] = betterproto.bytes_field(
        2, optional=True, group="_bytecode"
    )
    """Executable bytecode (optional)"""


@dataclass(eq=False, repr=False)
class SetOrDeleteDatastoreEntry(betterproto.Message):
    """Set or Delete DatastoreEntry"""

    type: "SetOrDeleteType" = betterproto.enum_field(1)
    """The type of the change"""

    datastore_entry: Optional["BytesMapFieldEntry"] = betterproto.message_field(
        2, optional=True, group="_datastore_entry"
    )
    """The balance of that entry (optioal)"""


@dataclass(eq=False, repr=False)
class DenunciationIndex(betterproto.Message):
    """Index for Denunciations in collections (e.g. like a HashMap...)"""

    block_header: "DenunciationBlockHeader" = betterproto.message_field(
        1, group="entry"
    )
    """Denunciation block header"""

    endorsement: "DenunciationEndorsement" = betterproto.message_field(2, group="entry")
    """Denunciation endorsement"""


@dataclass(eq=False, repr=False)
class DenunciationBlockHeader(betterproto.Message):
    """Variant for Block header denunciation index"""

    slot: "Slot" = betterproto.message_field(1)
    """Denounciation slot"""


@dataclass(eq=False, repr=False)
class DenunciationEndorsement(betterproto.Message):
    """Variant for Endorsement denunciation index"""

    slot: "Slot" = betterproto.message_field(1)
    """Denounciation slot"""

    index: int = betterproto.fixed32_field(2)
    """Denounciation index"""


@dataclass(eq=False, repr=False)
class MipStatusEntry(betterproto.Message):
    """Entry for GetMipStatusResponse"""

    mip_info: "MipInfo" = betterproto.message_field(1)
    """Mip info"""

    state_id: "ComponentStateId" = betterproto.enum_field(2)
    """State id"""


@dataclass(eq=False, repr=False)
class MipInfo(betterproto.Message):
    """MIP info (name & versions & time range for a MIP)"""

    name: str = betterproto.string_field(1)
    """MIP name or descriptive name"""

    version: int = betterproto.fixed32_field(2)
    """Network (or global) version (to be included in block header)"""

    start: int = betterproto.fixed64_field(3)
    """
    A timestamp at which the version gains its meaning (e.g. announced in block
    header)
    """

    timeout: int = betterproto.fixed64_field(4)
    """A timestamp at the which the deployment is considered failed"""

    activation_delay: int = betterproto.fixed64_field(5)
    """
    Once deployment has been locked, wait for this duration before deployment
    is considered active
    """

    components: List["MipComponentEntry"] = betterproto.message_field(6)
    """
    Components concerned by this versioning (e.g. a new Block version), and the
    associated component_version
    """


@dataclass(eq=False, repr=False)
class MipComponentEntry(betterproto.Message):
    """MipComponentEntry"""

    kind: "MipComponent" = betterproto.enum_field(1)
    """Kind"""

    version: int = betterproto.fixed32_field(2)
    """Version"""
